#!/usr/bin/env python

__author__ = 'bennypi'

import roslib; roslib.load_manifest('euroc_c2_demos')
import rospy
from euroc_c2_msgs.msg import *
from euroc_c2_msgs.srv import *
from math import pi


class ManipulationService(object):
    def __init__(self):
        servicename = '/euroc_interface_node/move_along_joint_path'
        rospy.wait_for_service(servicename)
        self.__move_service = rospy.ServiceProxy(servicename, MoveAlongJointPath)
        rospy.wait_for_service('/euroc_interface_node/get_timing_along_joint_path')
        self.__timing_service = rospy.ServiceProxy(servicename, GetTimingAlongJointPath)

    def move(self, path):
        # check if moveit generated a trajectory
        if len(path.joint_trajectory.points) == 0:
            return False

        joint_limits = []

        # create Cartesian Limits
        cartesian_limits = CartesianLimits()
        cartesian_limits.translational.max_velocity = 0.3
        cartesian_limits.translational.max_acceleration = 8
        cartesian_limits.rotational.max_velocity = 10 * pi / 180.0
        cartesian_limits.rotational.max_acceleration = 100 * pi / 180.0

        # for every joint in the list, create the appropriate limits and store them
        for i in range(len(path.joint_trajectory.joint_names)):
            limit = Limits()
            joint_name = path.joint_trajectory.joint_names[i]
            if joint_name.startswith("lwr"):
                limit.max_velocity = 50 * pi / 180.0
                limit.max_acceleration = 400 * pi / 180.0
            if joint_name.startswith("axis"):
                limit.max_velocity = 0.165
                limit.max_acceleration = 4
            if joint_name.startswith("joint_before_finger1"):
                limit.max_velocity = 0.5
                limit.max_acceleration = 20
            joint_limits.append(limit)

        # create the configuartionpath for the joints
        config = []
        # format the configuration for the gripper
        if path.joint_trajectory.joint_names[0].startswith("joint_before_finger"):
            # rename jointname
            path.joint_trajectory.joint_names = ["gripper"]
            # remove the second entry from the list as the service expects only one joint
            joint_limits.pop()
            # copy every configuration from the trajectory
            for i in range(len(path.joint_trajectory.points)):
                blub = SearchIkSolutionResponse()
                # because the gripper is only one joint but moveit returns two, we take the second value and double it
                blub.solution.q = [2 * path.joint_trajectory.points[i].positions[1]]
                if blub.solution.q[0] > 0.065:
                    blub.solution.q[0] = 0.065
                config.append(blub.solution)
        else:
            # copy the configuration generated by moveit into the expected object
            for i in range(len(path.joint_trajectory.points)):
                if i % 2 == 0:
                    blub = SearchIkSolutionResponse()
                    blub.solution.q = path.joint_trajectory.points[i].positions
                    config.append(blub.solution)

        # set the time
        ros_start_time = rospy.Time()
        ros_start_time.from_seconds(0)

        # call the service and store the response
        resp = self.__move_service(path.joint_trajectory.joint_names, config, ros_start_time, joint_limits, cartesian_limits)
        if resp.error_message:
            raise ManipulationServiceException(resp.error_message)
        if resp.stop_reason == "path finished":
            return True
        raise ManipulationServiceException(resp.error_message)

    def direct_move(self, configuration):
        cartesian_limits = CartesianLimits()
        cartesian_limits.translational.max_velocity = 0.165
        cartesian_limits.translational.max_acceleration = 4
        cartesian_limits.rotational.max_velocity = 10 * pi / 180.0
        cartesian_limits.rotational.max_acceleration = 100 * pi / 180.0

        joint_limits = []
        joint_names = []
        # for every joint in the list, create the appropriate limits and store them
        for i in range(1, 8):
            limit = Limits()
            joint_name = "lwr_joint_" + i.__str__()
            limit.max_velocity = 20 * pi / 180.0
            limit.max_acceleration = 400 * pi / 180.0
            joint_limits.append(limit)
            joint_names.append(joint_name)

        ros_start_time = rospy.Time()
        ros_start_time.from_seconds(0)

        # call the service and store the response
        resp = self.__move_service(joint_names, [configuration], ros_start_time, joint_limits, cartesian_limits)
        if resp.error_message:
            raise ManipulationServiceException(resp.error_message)
        if resp.stop_reason == "path finished":
            return True
        raise ManipulationServiceException(resp.error_message)

    def get_timing(self, path):
        # check if moveit generated a trajectory
        if len(path.joint_trajectory.points) == 0:
            return False

        joint_limits = []

        # create Cartesian Limits
        cartesian_limits = CartesianLimits()
        cartesian_limits.translational.max_velocity = 0.165
        cartesian_limits.translational.max_acceleration = 4
        cartesian_limits.rotational.max_velocity = 10 * pi / 180.0
        cartesian_limits.rotational.max_acceleration = 100 * pi / 180.0

        # for every joint in the list, create the appropriate limits and store them
        for i in range(len(path.joint_trajectory.joint_names)):
            limit = Limits()
            joint_name = path.joint_trajectory.joint_names[i]
            if joint_name.startswith("lwr"):
                limit.max_velocity = 20 * pi / 180.0
                limit.max_acceleration = 300 * pi / 180.0
            if joint_name.startswith("axis"):
                limit.max_velocity = 0.165
                limit.max_acceleration = 4
            if joint_name.startswith("joint_before_finger1"):
                limit.max_velocity = 0.5
                limit.max_acceleration = 20
            joint_limits.append(limit)

        # create the configuartionpath for the joints
        config = []
        # format the configuration for the gripper
        if path.joint_trajectory.joint_names[0].startswith("joint_before_finger"):
            # rename jointname
            path.joint_trajectory.joint_names = ["gripper"]
            # remove the second entry from the list as the service expects only one joint
            joint_limits.pop()
            # copy every configuration from the trajectory
            for i in range(len(path.joint_trajectory.points)):
                blub = SearchIkSolutionResponse()
                # because the gripper is only one joint but moveit returns two, we take the second value and double it
                blub.solution.q = [2 * path.joint_trajectory.points[i].positions[1]]
                if blub.solution.q[0] > 0.065:
                    blub.solution.q[0] = 0.065
                config.append(blub.solution)
        else:
            # copy the configuration generated by moveit into the expected object
            for i in range(len(path.joint_trajectory.points)):
                blub = SearchIkSolutionResponse()
                blub.solution.q = path.joint_trajectory.points[i].positions
                config.append(blub.solution)

        # set the time
        ros_start_time = rospy.Time()
        ros_start_time.from_seconds(0)

        # call the service and store the response
        resp = self.__timing_service(path.joint_trajectory.joint_names, config, joint_limits, cartesian_limits)
        return resp.time_at_via_point

    def pan_tilt(self, pan, tilt):
        cartesian_limits = CartesianLimits()
        cartesian_limits.translational.max_velocity = 0
        cartesian_limits.translational.max_acceleration = 0
        cartesian_limits.rotational.max_velocity = 0
        cartesian_limits.rotational.max_acceleration = 0
        joint_limits = []
        for i in range(0, 2):
            limit = Limits()
            limit.max_velocity = 0.4
            limit.max_acceleration = 2.0
            joint_limits.append(limit)
        config = []
        p = SearchIkSolutionResponse()
        p.solution.q = [pan, tilt]
        config.append(p.solution)
        ros_start_time = rospy.Time()
        ros_start_time.from_seconds(0)
        resp = self.__move_service(['cam_pan', 'cam_tilt'], config, ros_start_time, joint_limits, cartesian_limits)
        if resp.error_message:
            raise Exception(resp.error_message)
        return resp.stop_reason


# class for our own exception
class ManipulationServiceException(Exception):
    pass